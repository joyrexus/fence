// Generated by CoffeeScript 1.6.2
/*

# Fence

Convert your [literate script](http://ashkenas.com/literate-coffeescript/) to
a [GH-flavored code-fenced](https://help.github.com/articles/github-flavored-markdown) variant. 

Handy if you want to have your code blocks highlighted when posting 
your literate script as a Gist or as a README file for your repo.

HT to Mr. Ashkenas, this is but a tweak of [journo's Cakefile](https://github.com/jashkenas/journo/blob/master/Cakefile).

Example usage:

  fence demo.python.md > demo.md
  fence demo.coffee.md > demo.md
  fence demo.litcoffee > demo.md
  cat demo.python.md | fence --lang python > demo.md
  cat demo.coffee.md | fence --lang coffee > demo.md
*/


(function() {
  var getLang, makeFencer, method, name, run, unfence, _ref;

  getLang = function(file) {
    var ext;

    if (/\.(litcoffee|coffee\.md)$/.test(file)) {
      return 'coffeescript';
    }
    ext = file.match(/(\.(\w+))?\.(md)/);
    if (ext != null ? ext[1] : void 0) {
      return ext[2];
    } else {
      return '';
    }
  };

  makeFencer = function(lang) {
    if (lang == null) {
      lang = '';
    }
    return function(data) {
      var asFenced, indented, text;

      text = data.toString();
      indented = /\n\n    ([\s\S]*?)\n\n(?!    )/mg;
      asFenced = function(match, code) {
        var dedented;

        dedented = code.replace(/^    /mg, '');
        return "\n\n```" + lang + "\n" + dedented + "\n```\n";
      };
      return text.replace(indented, asFenced);
    };
  };

  unfence = function(source) {
    var fenced, indent, text;

    text = source.toString();
    fenced = /^```(?:\w+)?\n([\s\S]*?)\n```\n/mg;
    indent = function(match, code) {
      return code.replace(/^/mg, '    ') + "\n\n";
    };
    return text.replace(fenced, indent);
  };

  run = function() {
    var argv, convert, file, fs, lang, print, source, _i, _len, _ref, _results;

    fs = require('fs');
    argv = require('optimist').alias('u', 'undo').describe('u', 'Undo fencing (convert to indented)').alias('l', 'lang').describe('l', 'Language tag for fences').argv;
    if (argv.undo != null) {
      convert = unfence;
    }
    if (argv._.length) {
      _ref = argv._;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        lang = argv.lang || getLang(file);
        convert || (convert = makeFencer(lang));
        source = fs.readFileSync(file);
        _results.push(console.log(convert(source)));
      }
      return _results;
    } else {
      convert || (convert = makeFencer(argv.lang));
      print = function(source) {
        return console.log(convert(source));
      };
      process.stdin.on('data', print);
      return process.stdin.resume();
    }
  };

  _ref = {
    run: run,
    getLang: getLang,
    unfence: unfence,
    makeFencer: makeFencer
  };
  for (name in _ref) {
    method = _ref[name];
    exports[name] = method;
  }

}).call(this);
